!function(n,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.MIPSAssem=e():n.MIPSAssem=e()}(this,function(){return function(n){var e={};function t(r){if(e[r])return e[r].exports;var s=e[r]={i:r,l:!1,exports:{}};return n[r].call(s.exports,s,s.exports,t),s.l=!0,s.exports}return t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var s in n)t.d(r,s,function(e){return n[e]}.bind(null,s));return r},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=1)}([function(module,exports,__webpack_require__){var factory;"undefined"!=typeof self&&self,factory=function(){return function(n){var e={};function t(r){if(e[r])return e[r].exports;var s=e[r]={i:r,l:!1,exports:{}};return n[r].call(s.exports,s,s.exports,t),s.l=!0,s.exports}return t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var s in n)t.d(r,s,function(e){return n[e]}.bind(null,s));return r},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s="./src/index.js")}({"./src/bitstrings.js":
/*!***************************!*\
  !*** ./src/bitstrings.js ***!
  \***************************/
/*! exports provided: isBinaryLiteral, compareBits, makeBitMaskFromString, makeBitMask, padBitString */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBinaryLiteral", function() { return isBinaryLiteral; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareBits", function() { return compareBits; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeBitMaskFromString", function() { return makeBitMaskFromString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeBitMask", function() { return makeBitMask; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padBitString", function() { return padBitString; });\nfunction isBinaryLiteral(str) {\n  return str[0] === "0" || str[0] === "1"; // Checking first char is enough for now\n}\n\nfunction compareBits(number, bitString, bitOffset) {\n  let shifted = (number >>> bitOffset) & makeBitMask(bitString.length);\n  let mask = makeBitMaskFromString(bitString);\n  return shifted === mask;\n}\n\nfunction makeBitMaskFromString(bitString) {\n  let mask = 0;\n  for (var i = 0; i < bitString.length; i++) {\n    let bit = bitString[i] === "1" ? 1 : 0;\n    mask <<= 1;\n    mask = mask | bit;\n  }\n  return mask;\n}\n\nfunction makeBitMask(len) {\n  if (len <= 0)\n    throw new Error(`makeBitMask cannot make mask of length ${len}`);\n\n  let mask = 1;\n  while (--len) {\n    mask <<= 1;\n    mask = mask | 1;\n  }\n  return mask;\n}\n\nfunction padBitString(str, minLen) {\n  while (str.length < minLen) {\n    str = "0" + str;\n  }\n  return str;\n}\n\n\n//# sourceURL=webpack://MIPSInst/./src/bitstrings.js?')},"./src/immediates.js":
/*!***************************!*\
  !*** ./src/immediates.js ***!
  \***************************/
/*! exports provided: parseImmediate, formatImmediate, makeInt16, getImmFormatDetails */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseImmediate", function() { return parseImmediate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatImmediate", function() { return formatImmediate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeInt16", function() { return makeInt16; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImmFormatDetails", function() { return getImmFormatDetails; });\nfunction parseImmediate(immArr, maxBits, signed, shift) {\n  let [neg, base, num] = immArr;\n  base = base.toLowerCase();\n\n  let value;\n  if (base === "b")\n    value = parseInt(num, 2);\n  else if (base === "o")\n    value = parseInt(num, 8);\n  else if (base === "x")\n    value = parseInt(num, 16);\n  else\n    value = parseInt(num, 10);\n\n  if (isNaN(value)) {\n    return value; // Let the caller decide what to do with NaN.\n  }\n\n  if (shift) {\n    value >>>= shift;\n  }\n\n  if (maxBits === 16) {\n    if (signed) {\n      value = makeInt16(value);\n    }\n  }\n\n  if (neg)\n    value = -value;\n\n  return value;\n}\n\nfunction formatImmediate(value, maxBits) {\n  if (maxBits === 16) {\n    value = (new Uint16Array([value]))[0];\n  }\n\n  return value;\n}\n\nfunction makeInt16(value) {\n  return (new Int16Array([value]))[0];\n}\n\nfunction getImmFormatDetails(formatVal) {\n  // Remove optional indicator\n  if (formatVal[formatVal.length - 1] === "?")\n    formatVal = formatVal.substring(0, formatVal.length - 1);\n\n  if (formatVal.indexOf("int") === -1) {\n    if (formatVal.substr(0, 2) === "cc") {\n      return {\n        signed: false,\n        bits: 4,\n        shift: false,\n      };\n    }\n\n    return null; // Not an immediate\n  }\n\n  let shift = 0;\n  const shiftIndex = formatVal.indexOf("shift");\n  if (shiftIndex > 0)\n    shift = formatVal.substr(shiftIndex).match(/\\d+/g);\n\n  return {\n    signed: formatVal[0] !== "u",\n    bits: parseInt(formatVal.match(/\\d+/g)),\n    shift: shift,\n  };\n}\n\n\n//# sourceURL=webpack://MIPSInst/./src/immediates.js?')},"./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: parse, print */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse */ "./src/parse.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return _parse__WEBPACK_IMPORTED_MODULE_0__["parse"]; });\n\n/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./print */ "./src/print.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "print", function() { return _print__WEBPACK_IMPORTED_MODULE_1__["print"]; });\n\n\n\n\n\n\n//# sourceURL=webpack://MIPSInst/./src/index.js?')},"./src/opcodes.js":
/*!************************!*\
  !*** ./src/opcodes.js ***!
  \************************/
/*! exports provided: getOpcodeDetails, getValueBitLength, findMatch */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOpcodeDetails", function() { return getOpcodeDetails; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValueBitLength", function() { return getValueBitLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findMatch", function() { return findMatch; });\n/* harmony import */ var _regs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regs */ "./src/regs.js");\n/* harmony import */ var _bitstrings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bitstrings */ "./src/bitstrings.js");\n/* harmony import */ var _immediates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./immediates */ "./src/immediates.js");\n\n\n\n\nconst rs = "rs";\nconst rt = "rt";\nconst rd = "rd";\nconst fs = "fs";\nconst ft = "ft";\nconst fd = "fd";\nconst fr = "fr";\nconst sa = "uint5";\nconst uint5 = "uint5";\nconst uint10 = "uint10";\nconst int16 = "int16";\nconst uint16 = "uint16";\nconst uint20 = "uint20";\nconst uint26 = "uint26";\nconst uint26shift2 = "uint26shift2";\nconst cc = "cc";\nconst cond = "cond";\nconst fmt = "fmt";\nconst fmt3 = "fmt3";\n\nfunction getOpcodeDetails(opcode) {\n  return opcodeDetails[opcode.toLowerCase()];\n}\n\nfunction getValueBitLength(str) {\n  if (Object(_bitstrings__WEBPACK_IMPORTED_MODULE_1__["isBinaryLiteral"])(str))\n    return str.length;\n\n  str = str.replace("?", "");\n  switch (str) {\n    case "cc":\n    case "fmt3":\n      return 3;\n\n    case "cond":\n      return 4;\n\n    case "rs":\n    case "rt":\n    case "rd":\n    case "fs":\n    case "ft":\n    case "fd":\n    case "fr":\n    case "sa":\n    case "fmt":\n      return 5;\n  }\n\n  const immDetails = Object(_immediates__WEBPACK_IMPORTED_MODULE_2__["getImmFormatDetails"])(str);\n  if (immDetails) {\n    return immDetails.bits;\n  }\n\n  throw new Error(`Unrecongized format value: ${str}`);\n}\n\n// returns name\nfunction findMatch(inst) {\n  let bestMatch = "";\n  let bestMatchScore = 0;\n  for (let opName in opcodeDetails) {\n    const format = opcodeDetails[opName].format;\n    const fmts = opcodeDetails[opName].fmts;\n    const score = formatMatches(inst, format, fmts);\n    if (score > bestMatchScore) {\n      bestMatch = opName;\n      bestMatchScore = score;\n    }\n  }\n\n  return bestMatch;\n}\n\n// Returns number of literal bits matched, if the overall format matches.\nfunction formatMatches(number, format, fmts) {\n  let score = 0;\n  let tempScore;\n  let bitOffset = 0;\n  for (let i = format.length - 1; i >= 0; i--) {\n    let bitLength;\n    let piece = format[i];\n    if (Array.isArray(piece)) {\n      let matchedOne = false;\n      for (let j = 0; j < piece.length; j++) {\n        tempScore = checkPiece(piece[j], number, bitOffset, fmts);\n        if (tempScore >= 0) {\n          matchedOne = true;\n          score += tempScore;\n          bitLength = getValueBitLength(piece[j]);\n          break; // j\n        }\n      }\n      if (!matchedOne)\n        return 0;\n    }\n    else {\n      tempScore = checkPiece(piece, number, bitOffset, fmts);\n      if (tempScore >= 0) {\n        score += tempScore;\n        bitLength = getValueBitLength(piece);\n      }\n      else {\n        return 0;\n      }\n    }\n\n    bitOffset += bitLength;\n  }\n\n  return score;\n}\n\nfunction checkPiece(piece, number, bitOffset, fmts) {\n  if (!Object(_bitstrings__WEBPACK_IMPORTED_MODULE_1__["isBinaryLiteral"])(piece)) {\n    if (piece === fmt) {\n      for (let i = 0; i < fmts.length; i++) {\n        let fmtBitString = Object(_bitstrings__WEBPACK_IMPORTED_MODULE_1__["padBitString"])(Object(_regs__WEBPACK_IMPORTED_MODULE_0__["getFmtBits"])(fmts[i]).toString(2), 5);\n        if (Object(_bitstrings__WEBPACK_IMPORTED_MODULE_1__["compareBits"])(number, fmtBitString, bitOffset))\n          return fmtBitString.length;\n      }\n      return -1;\n    }\n\n    if (piece === fmt3) {\n      for (let i = 0; i < fmts.length; i++) {\n        let fmtBitString = Object(_bitstrings__WEBPACK_IMPORTED_MODULE_1__["padBitString"])(Object(_regs__WEBPACK_IMPORTED_MODULE_0__["getFmt3Bits"])(fmts[i]).toString(2), 3);\n        if (Object(_bitstrings__WEBPACK_IMPORTED_MODULE_1__["compareBits"])(number, fmtBitString, bitOffset))\n          return fmtBitString.length;\n      }\n      return -1;\n    }\n\n    return 0; // non-literal contributes nothing\n  }\n\n  if (Object(_bitstrings__WEBPACK_IMPORTED_MODULE_1__["compareBits"])(number, piece, bitOffset))\n    return piece.length;\n\n  return -1;\n}\n\nconst opcodeDetails = {\n  "abs.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "000101"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  add: {\n    format: ["000000", rs, rt, rd, "00000100000"],\n    display: [rd, rs, rt],\n  },\n  "add.fmt": {\n    format: ["010001", fmt, ft, fs, fd, "000000"],\n    fmts: ["S", "D"],\n    display: [fd, fs, ft],\n  },\n  addi: {\n    format: ["001000", rs, rt, int16],\n    display: [rt, rs, int16],\n  },\n  addiu: {\n    format: ["001001", rs, rt, uint16],\n    display: [rt, rs, uint16],\n  },\n  addu: {\n    format: ["000000", rs, rt, rd, "00000100001"],\n    display: [rd, rs, rt],\n  },\n  and: {\n    format: ["000000", rs, rt, rd, "00000100100"],\n    display: [rd, rs, rt],\n  },\n  andi: {\n    format: ["001100", rs, rt, uint16],\n    display: [rt, rs, uint16],\n  },\n  bc1f: {\n    format: ["010001", "01000", [cc, "000"], "00", int16], // TODO shifting?\n    display: ["cc?", int16], // offset\n  },\n  bc1fl: {\n    format: ["010001", "01000", [cc, "000"], "10", int16],\n    display: ["cc?", int16], // offset\n  },\n  bc1t: {\n    format: ["010001", "01000", [cc, "000"], "01", int16],\n    display: ["cc?", int16], // offset\n  },\n  bc1tl: {\n    format: ["010001", "01000", [cc, "000"], "11", int16],\n    display: ["cc?", int16], // offset\n  },\n  beq: {\n    format: ["000100", rs, rt, uint16],\n    display: [rs, rt, uint16], // offset\n  },\n  beql: {\n    format: ["010100", rs, rt, uint16],\n    display: [rs, rt, uint16], // offset\n  },\n  bgez: {\n    format: ["000001", rs, "00001", uint16],\n    display: [rs, uint16], // offset\n  },\n  bgezal: {\n    format: ["000001", rs, "10001", uint16],\n    display: [rs, uint16], // offset\n  },\n  bgezall: {\n    format: ["000001", rs, "10011", uint16],\n    display: [rs, uint16], // offset\n  },\n  bgezl: {\n    format: ["000001", rs, "00011", uint16],\n    display: [rs, uint16], // offset\n  },\n  bgtz: {\n    format: ["000111", rs, "00000", uint16],\n    display: [rs, uint16], // offset\n  },\n  bgtzl: {\n    format: ["010111", rs, "00000", uint16],\n    display: [rs, uint16], // offset\n  },\n  blez: {\n    format: ["000110", rs, "00000", uint16],\n    display: [rs, uint16], // offset\n  },\n  blezl: {\n    format: ["010110", rs, "00000", uint16],\n    display: [rs, uint16], // offset\n  },\n  bltz: {\n    format: ["000001", rs, "00000", uint16],\n    display: [rs, uint16], // offset\n  },\n  bltzal: {\n    format: ["000001", rs, "10000", uint16],\n    display: [rs, uint16], // offset\n  },\n  bltzall: {\n    format: ["000001", rs, "10010", uint16],\n    display: [rs, uint16], // offset\n  },\n  bltzl: {\n    format: ["000001", rs, "00010", uint16],\n    display: [rs, uint16], // offset\n  },\n  bne: {\n    format: ["000101", rs, rt, uint16],\n    display: [rs, rt, uint16], // offset\n  },\n  bnel: {\n    format: ["010101", rs, rt, uint16],\n    display: [rs, rt, uint16], // offset\n  },\n  break: {\n    format: ["000000", [uint20, "00000000000000000000"], "001101"],\n    display: ["uint20?"],\n  },\n  "c.cond.fmt": {\n    format: ["010001", fmt, ft, fs, [cc, "000"], "00", "11", cond],\n    fmts: ["S", "D"],\n    display: ["cc?", fs, ft],\n  },\n  "ceil.l.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "001010"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  "ceil.w.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "001110"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  cfc1: {\n    format: ["010001", "00010", rt, fs, "00000000000"],\n    display: [rt, fs],\n  },\n  ctc1: {\n    format: ["010001", "00110", rt, fs, "00000000000"],\n    display: [rt, fs],\n  },\n  cop0: {\n    format: ["010000", uint26],\n    display: [uint26], // cop_fun\n  },\n  cop1: {\n    format: ["010001", uint26],\n    display: [uint26], // cop_fun\n  },\n  cop2: {\n    format: ["010010", uint26],\n    display: [uint26], // cop_fun\n  },\n  cop3: {\n    format: ["010011", uint26],\n    display: [uint26], // cop_fun\n  },\n  "cvt.d.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "100001"],\n    fmts: ["S", "W", "L"],\n    display: [fd, fs],\n  },\n  "cvt.l.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "100101"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  "cvt.s.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "100000"],\n    fmts: ["D", "W", "L"],\n    display: [fd, fs],\n  },\n  "cvt.w.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "100100"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  dadd: {\n    format: ["000000", rs, rt, rd, "00000101100"],\n    display: [rd, rs, rt],\n  },\n  daddi: {\n    format: ["011000", rs, rt, int16],\n    display: [rt, rs, int16],\n  },\n  daddiu: {\n    format: ["011001", rs, rt, uint16],\n    display: [rt, rs, uint16],\n  },\n  daddu: {\n    format: ["000000", rs, rt, rd, "00000101101"],\n    display: [rd, rs, rt],\n  },\n  ddiv: {\n    format: ["000000", rs, rt, "0000000000011110"],\n    display: [rs, rt],\n  },\n  ddivu: {\n    format: ["000000", rs, rt, "0000000000011111"],\n    display: [rs, rt],\n  },\n  div: {\n    format: ["000000", rs, rt, "0000000000011010"],\n    display: [rs, rt],\n  },\n  "div.fmt": {\n    format: ["010001", fmt, ft, fs, fd, "000011"],\n    fmts: ["S", "D"],\n    display: [fd, fs, ft],\n  },\n  divu: {\n    format: ["000000", rs, rt, "0000000000011011"],\n    display: [rs, rt],\n  },\n  dmfc1: {\n    format: ["010001", "00001", rt, fs, "00000000000"],\n    display: [rt, fs],\n  },\n  dmult: {\n    format: ["000000", rs, rt, "0000000000011100"],\n    display: [rs, rt],\n  },\n  dmultu: {\n    format: ["000000", rs, rt, "0000000000011101"],\n    display: [rs, rt],\n  },\n  dmtc1: {\n    format: ["010001", "00101", rt, fs, "00000000000"],\n    display: [rt, fs],\n  },\n  dsll: {\n    format: ["00000000000", rt, rd, sa, "111000"],\n    display: [rd, rt, sa],\n  },\n  dsll32: {\n    format: ["00000000000", rt, rd, sa, "111100"],\n    display: [rd, rt, sa],\n  },\n  dsllv: {\n    format: ["000000", rs, rt, rd, "00000010100"],\n    display: [rd, rt, rs],\n  },\n  dsra: {\n    format: ["00000000000", rt, rd, sa, "111011"],\n    display: [rd, rt, sa],\n  },\n  dsra32: {\n    format: ["00000000000", rt, rd, sa, "111111"],\n    display: [rd, rt, sa],\n  },\n  dsrav: {\n    format: ["000000", rs, rt, rd, "00000010111"],\n    display: [rd, rt, rs],\n  },\n  dsrl: {\n    format: ["00000000000", rt, rd, sa, "111010"],\n    display: [rd, rt, sa],\n  },\n  dsrl32: {\n    format: ["00000000000", rt, rd, sa, "111110"],\n    display: [rd, rt, sa],\n  },\n  dsrlv: {\n    format: ["000000", rs, rt, rd, "00000010110"],\n    display: [rd, rt, rs],\n  },\n  dsub: {\n    format: ["000000", rs, rt, rd, "00000101110"],\n    display: [rd, rs, rt],\n  },\n  dsubu: {\n    format: ["000000", rs, rt, rd, "00000101111"],\n    display: [rd, rs, rt],\n  },\n  "floor.l.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "001011"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  "floor.w.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "001111"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  j: {\n    format: ["000010", uint26shift2],\n    display: [uint26shift2],\n  },\n  jal: {\n    format: ["000011", uint26shift2],\n    display: [uint26shift2],\n  },\n  jalr: {\n    format: ["000000", rs, "00000", [rd, "11111"], "00000", "001001"],\n    display: ["rd?", rs],\n  },\n  jr: {\n    format: ["000000", rs, "000000000000000", "001000"],\n    display: [rs],\n  },\n  lb: {\n    format: ["100000", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  lbu: {\n    format: ["100100", rs, rt, uint16],\n    display: [rt, uint16, "(", rs, ")"], // offset\n  },\n  ld: {\n    format: ["110111", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  ldc1: {\n    format: ["110101", rs, ft, int16],\n    display: [ft, int16, "(", rs, ")"], // offset\n  },\n  ldc2: {\n    format: ["110110", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  ldl: {\n    format: ["011010", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  ldr: {\n    format: ["011011", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  ldxc1: {\n    format: ["010011", rs, rt, "00000", fd, "000001"],\n    display: [fd, rt, "(", rs, ")"], // offset\n  },\n  lh: {\n    format: ["100001", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  lhu: {\n    format: ["100101", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  ll: {\n    format: ["110000", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  lld: {\n    format: ["110100", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  lui: {\n    format: ["001111", "00000", rt, uint16],\n    display: [rt, uint16],\n  },\n  lw: {\n    format: ["100011", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  lwc1: {\n    format: ["110001", rs, ft, int16],\n    display: [ft, int16, "(", rs, ")"], // offset\n  },\n  lwc2: {\n    format: ["110010", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  lwc3: {\n    format: ["110011" ,rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  lwl: {\n    format: ["100010", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  lwr: {\n    format: ["100110", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  lwu: {\n    format: ["100111", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  lwxc1: {\n    format: ["010011", rs, rt, "00000", fd, "000000"],\n    display: [fd, rt, "(", rs, ")"],\n  },\n  "madd.fmt": {\n    format: ["010011", fr, ft, fs, fd, "100", fmt3],\n    fmts: ["S", "D"],\n    display: [fd, fr, fs, ft],\n  },\n  mfc1: {\n    format: ["010001", "00000", rt, fs, "00000000000"],\n    display: [rt, fs],\n  },\n  mfhi: {\n    format: ["000000", "0000000000", rd, "00000", "010000"],\n    display: [rd],\n  },\n  mflo: {\n    format: ["000000", "0000000000", rd, "00000", "010010"],\n    display: [rd],\n  },\n  "mov.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "000110"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  movf: {\n    format: ["000000", rs, cc, "00", rd, "00000", "000001"],\n    display: [rd, rs, cc],\n  },\n  "movf.fmt": {\n    format: ["010001", fmt, cc, "00", fs, fd, "010001"],\n    fmts: ["S", "D"],\n    display: [fd, fs, cc],\n  },\n  movn: {\n    format: ["000000", rs, rt, rd, "00000", "001011"],\n    display: [rd, rs, rt],\n  },\n  "movn.fmt": {\n    format: ["010001", fmt, rt, fs, fd, "010011"],\n    fmts: ["S", "D"],\n    display: [fd, fs, rt],\n  },\n  movt: {\n    format: ["000000", rs, cc, "01", rd, "00000", "000001"],\n    display: [rd, rs, cc],\n  },\n  "movt.fmt": {\n    format: ["010001", fmt, cc, "01", fs, fd, "010001"],\n    fmts: ["S", "D"],\n    display: [fd, fs, cc],\n  },\n  movz: {\n    format: ["000000", rs, rt, rd, "00000", "001010"],\n    display: [rd, rs, rt],\n  },\n  "movz.fmt": {\n    format: ["010001", fmt, rt, fs, fd, "010010"],\n    fmts: ["S", "D"],\n    display: [fd, fs, rt],\n  },\n  "msub.fmt": {\n    format: ["010011", fr, ft, fs, fd, "101", fmt3],\n    fmts: ["S", "D"],\n    display: [fd, fr, fs, ft],\n  },\n  mtc1: {\n    format: ["010001", "00100", rt, fs, "00000000000"],\n    display: [rt, fs],\n  },\n  mthi: {\n    format: ["000000", rs, "000000000000000", "010001"],\n    display: [rs],\n  },\n  mtlo: {\n    format: ["000000", rs, "000000000000000", "010011"],\n    display: [rs],\n  },\n  "mul.fmt": {\n    format: ["010001", fmt, ft, fs, fd, "000010"],\n    fmts: ["S", "D"],\n    display: [fd, fs, ft],\n  },\n  mult: {\n    format: ["000000", rs, rt, "0000000000", "011000"],\n    display: [rs, rt],\n  },\n  multu: {\n    format: ["000000", rs, rt, "0000000000", "011001"],\n    display: [rs, rt],\n  },\n  "neg.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "000111"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  "nmadd.fmt": {\n    format: ["010011", fr, ft, fs, fd, "110", fmt3],\n    fmts: ["S", "D"],\n    display: [fd, fr, fs, ft],\n  },\n  "nmsub.fmt": {\n    format: ["010011", fr, ft, fs, fd, "111", fmt3],\n    fmts: ["S", "D"],\n    display: [fd, fr, fs, ft],\n  },\n  nop: {\n    format: ["00000000000000000000000000000000"],\n    display: [],\n  },\n  nor: {\n    format: ["000000", rs, rt, rd, "00000", "100111"],\n    display: [rd, rs, rt],\n  },\n  or: {\n    format: ["000000", rs, rt, rd, "00000", "100101"],\n    display: [rd, rs, rt],\n  },\n  ori: {\n    format: ["001101", rs, rt, uint16],\n    display: [rt, rs, uint16],\n  },\n  pref: {\n    format: ["110011", rs, uint5, int16],\n    display: [uint5, int16, "(", rs, ")"], // hint, offset, base\n  },\n  prefx: {\n    format: ["010011", rs, rt, uint5, "00000", "001111"],\n    display: [uint5, rt, "(", rs, ")"], // hint, index, base\n  },\n  "recip.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "010101"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  "round.l.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "001000"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  "round.w.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "001100"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  "rsqrt.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "010110"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  sb: {\n    format: ["101000", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  sc: {\n    format: ["111000", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  scd: {\n    format: ["111100", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  sd: {\n    format: ["111111", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  sdc1: {\n    format: ["111101", rs, ft, int16],\n    display: [ft, int16, "(", rs, ")"], // offset\n  },\n  sdc2: {\n    format: ["111110", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  sdl: {\n    format: ["101100", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  sdr: {\n    format: ["101101", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  sdxc1: {\n    format: ["010011", rs, uint5, fs, "00000", "001001"],\n    display: [fs, uint5, "(", rs, ")"],\n  },\n  sh: {\n    format: ["101001", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"], // offset\n  },\n  sll: {\n    format: ["000000", "00000", rt, rd, sa, "000000"],\n    display: [rd, rt, sa],\n  },\n  sllv: {\n    format: ["000000", rs, rt, rd, "00000", "000100"],\n    display: [rd, rt, rs],\n  },\n  slt: {\n    format: ["000000", rs, rt, rd, "00000", "101010"],\n    display: [rd, rs, rt],\n  },\n  slti: {\n    format: ["001010", rs, rt, int16],\n    display: [rt, rs, int16],\n  },\n  sltiu: {\n    format: ["001011", rs, rt, uint16],\n    display: [rt, rs, uint16],\n  },\n  sltu: {\n    format: ["000000", rs, rt, rd, "00000", "101011"],\n    display: [rd, rs, rt],\n  },\n  "sqrt.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "000100"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  sra: {\n    format: ["000000", "00000", rt, rd, sa, "000011"],\n    display: [rd, rt, sa],\n  },\n  srav: {\n    format: ["000000", rs, rt, rd, "00000", "000111"],\n    display: [rd, rt, rs],\n  },\n  srl: {\n    format: ["000000", "00000", rt, rd, sa, "000010"],\n    display: [rd, rt, sa],\n  },\n  srlv: {\n    format: ["000000", rs, rt, rd, "00000", "000110"],\n    display: [rd, rt, rs],\n  },\n  sub: {\n    format: ["000000", rs, rt, rd, "00000", "100010"],\n    display: [rd, rs, rt],\n  },\n  "sub.fmt": {\n    format: ["010001", fmt, ft, fs, fd, "000001"],\n    fmts: ["S", "D"],\n    display: [fd, fs, ft],\n  },\n  subu: {\n    format: ["000000", rs, rt, rd, "00000", "100011"],\n    display: [rd, rs, rt],\n  },\n  sw: {\n    format: ["101011", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"],\n  },\n  swc1: {\n    format: ["111001", rs, ft, int16],\n    display: [ft, int16, "(", rs, ")"],\n  },\n  swc2: {\n    format: ["111010", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"],\n  },\n  swc3: {\n    format: ["111011", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"],\n  },\n  swl: {\n    format: ["101010", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"],\n  },\n  swr: {\n    format: ["101110", rs, rt, int16],\n    display: [rt, int16, "(", rs, ")"],\n  },\n  swxc1: {\n    format: ["010011", rs, uint5, fs, "00000", "001000"],\n    display: [fs, uint5, "(", rs, ")"],\n  },\n  sync: {\n    format: ["000000", "000000000000000", "00000", "001111"],\n    display: [],\n  },\n  syscall: {\n    format: ["000000", [uint20, "00000000000000000000"], "001100"],\n    display: [],\n  },\n  teq: {\n    format: ["000000", rs, rt, uint10, "110100"],\n    display: [rs, rt],\n  },\n  teqi: {\n    format: ["000001", rs, "01100", int16],\n    display: [rs, int16],\n  },\n  tge: {\n    format: ["000000", rs, rt, uint10, "110000"],\n    display: [rs, rt],\n  },\n  tgei: {\n    format: ["000001", rs, "01000", int16],\n    display: [rs, int16],\n  },\n  tgeiu: {\n    format: ["000001", rs, "01001", uint16],\n    display: [rs, uint16],\n  },\n  tgeu: {\n    format: ["000000", rs, rt, uint10, "110001"],\n    display: [rs, rt],\n  },\n  tlt: {\n    format: ["000000", rs, rt, uint10, "110010"],\n    display: [rs, rt],\n  },\n  tlti: {\n    format: ["000001", rs, "01010", int16],\n    display: [rs, int16],\n  },\n  tltiu: {\n    format: ["000001", rs, "01011", uint16],\n    display: [rs, uint16],\n  },\n  tltu: {\n    format: ["000000", rs, rt, uint10, "110011"],\n    display: [rs, rt],\n  },\n  tne: {\n    format: ["000000", rs, rt, uint10, "110110"],\n    display: [rs, rt],\n  },\n  tnei: {\n    format: ["000001", rs, "01110", int16],\n    display: [rs, int16],\n  },\n  "trunc.l.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "001001"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  "trunc.w.fmt": {\n    format: ["010001", fmt, "00000", fs, fd, "001101"],\n    fmts: ["S", "D"],\n    display: [fd, fs],\n  },\n  xor: {\n    format: ["000000", rs, rt, rd, "00000", "100110"],\n    display: [rd, rs, rt],\n  },\n  xori: {\n    format: ["001110", rs, rt, uint16],\n    display: [rt, rs, uint16],\n  },\n};\n\n\n//# sourceURL=webpack://MIPSInst/./src/opcodes.js?')},"./src/parse.js":
/*!**********************!*\
  !*** ./src/parse.js ***!
  \**********************/
/*! exports provided: parse */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });\n/* harmony import */ var _opcodes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./opcodes */ "./src/opcodes.js");\n/* harmony import */ var _immediates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./immediates */ "./src/immediates.js");\n/* harmony import */ var _regs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./regs */ "./src/regs.js");\n/* harmony import */ var _regex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./regex */ "./src/regex.js");\n/* harmony import */ var _bitstrings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bitstrings */ "./src/bitstrings.js");\n\n\n\n\n\n\n/**\n * Parses a string MIPS instruction, returning numeric machine code.\n *\n * With the `intermediate` option, this can also be used as a convenient base\n * for an assembler. The object output with `intermediate` can be manipulated\n * prior to calling `parse` with it again.\n * @param {String|Array|Object} value MIPS instruction, or intermediate object format.\n * @param {Object} opts Behavior options\n * @param {Boolean} opts.intermediate: Output an object intermediate format instead of a number\n * @returns {Number|Array|Object} Returns a numeric representation of the given\n * MIPS instruction string.\n * If multiple values are given (array) then multiple values are returned.\n * When the `intermediate` option is passed, the return type is an object.\n */\nfunction parse(value, opts) {\n  opts = _getFinalOpts(opts);\n\n  if (Array.isArray(value)) {\n    return value.map(s => _parse(s, opts));\n  }\n  if (typeof value === "object") {\n    return _parse(value, opts);\n  }\n  if (typeof value === "string") {\n    const values = value.split(/\\r?\\n/).filter(v => !!(v.trim()));\n    if (values.length === 1)\n      return _parse(values[0], opts);\n    else\n      return values.map(s => _parse(s, opts));\n  }\n\n  throw new Error("Unexpected input to parse. Pass a string or array of strings.");\n}\n\nfunction _getFinalOpts(givenOpts) {\n  return Object.assign({\n    intermediate: false,\n  }, givenOpts);\n}\n\nfunction _parse(value, opts) {\n  let opcode, opcodeObj, values;\n  if (typeof value === "string") {\n    opcode = _regex__WEBPACK_IMPORTED_MODULE_3__["getOpcode"](value);\n    if (!opcode)\n      throw new Error(`Could not parse opcode from ${value}`);\n\n    opcodeObj = Object(_opcodes__WEBPACK_IMPORTED_MODULE_0__["getOpcodeDetails"])(opcode);\n    if (!opcodeObj)\n      throw new Error(`Opcode ${opcode} was not recognized`);\n\n    values = _parseValues(opcode, opcodeObj, value);\n  }\n  else if (typeof value === "object") {\n    opcode = _regex__WEBPACK_IMPORTED_MODULE_3__["getOpcode"](value.op);\n    if (!opcode)\n      throw new Error("Object input to parse did not contain \'op\'");\n\n    opcodeObj = Object(_opcodes__WEBPACK_IMPORTED_MODULE_0__["getOpcodeDetails"])(opcode);\n    if (!opcodeObj)\n      throw new Error(`Opcode ${opcode} was not recognized`);\n\n    values = value;\n  }\n\n  if (opts.intermediate)\n    return values;\n\n  return bitsFromFormat(opcodeObj.format, values);\n}\n\nfunction _parseValues(opcode, opcodeObj, value) {\n  let regex = _regex__WEBPACK_IMPORTED_MODULE_3__["makeRegexForOpcode"](opcode, opcodeObj);\n  let match = regex.exec(value);\n  if (!match)\n    throw new Error(`Could not parse instruction: ${value}`);\n\n  let values = {\n    op: opcode\n  };\n\n  if (opcode.indexOf(".fmt") !== -1 || opcode.indexOf(".cond") !== -1) {\n    determineOpcodeValues(match[1], opcode, opcodeObj.fmts, opcodeObj.format, values);\n  }\n\n  const display = opcodeObj.display;\n  let matchIndex = 2; // 0 is whole match, 1 is opcode - skip both\n  for (let i = 0; i < display.length; i++, matchIndex++) {\n    const parsedVal = match[matchIndex];\n    let displayEntry = display[i];\n\n    const optional = displayEntry.endsWith("?");\n    if (optional) {\n      displayEntry = displayEntry.replace("?", "");\n    }\n\n    switch (displayEntry) {\n      case "(":\n      case ")":\n        matchIndex--; // Eh\n        continue;\n\n      case "rs":\n      case "rd":\n      case "rt": {\n        const tryReg = Object(_regs__WEBPACK_IMPORTED_MODULE_2__["getRegBits"])(parsedVal);\n        if (tryReg === undefined) {\n          if (optional)\n            continue;\n\n          throw new Error(`Unrecognized ${displayEntry} register ${parsedVal}`);\n        }\n        values[displayEntry] = tryReg;\n        continue;\n      }\n\n      case "fs":\n      case "ft":\n      case "fd":\n      case "fr":\n        values[displayEntry] = parseInt(parsedVal);\n        if (isNaN(values[displayEntry]))\n          throw new Error(`Unrecognized ${displayEntry} register ${parsedVal}`);\n        continue;\n    }\n\n    const immDetails = Object(_immediates__WEBPACK_IMPORTED_MODULE_1__["getImmFormatDetails"])(displayEntry);\n    if (immDetails) {\n      let value;\n      const immPieces = [match[matchIndex], match[matchIndex + 1], match[matchIndex + 2]];\n\n      if (!optional || immPieces[2]) {\n        value = Object(_immediates__WEBPACK_IMPORTED_MODULE_1__["parseImmediate"])(immPieces, immDetails.bits, immDetails.signed, immDetails.shift);\n        if (isNaN(value)) {\n          throw new Error(`Could not parse immediate ${immPieces.join("")}`);\n        }\n        values[displayEntry] = value;\n      }\n\n      matchIndex += 2;\n\n      continue;\n    }\n\n    throw new Error(`Unrecognized opcode display entry ${displayEntry}`);\n  }\n\n  return values;\n}\n\nfunction bitsFromFormat(format, values) {\n  let output = 0;\n  let bitOffset = 0;\n  for (let i = 0; i < format.length; i++) {\n    let writeResult;\n    let piece = format[i];\n    let bitLength = Object(_opcodes__WEBPACK_IMPORTED_MODULE_0__["getValueBitLength"])(Array.isArray(piece) ? piece[0] : piece);\n    output = (output << bitLength) >>> 0;\n    if (Array.isArray(piece)) {\n      for (let j = 0; j < piece.length; j++) {\n        writeResult = writeBitsForPiece(piece[j], output, values);\n        if (writeResult.wrote) {\n          output = writeResult.output;\n          break; // j\n        }\n      }\n    }\n    else {\n      writeResult = writeBitsForPiece(piece, output, values);\n      if (writeResult.wrote) {\n        output = writeResult.output;\n      }\n    }\n\n    bitOffset += bitLength;\n  }\n\n  if (bitOffset != 32)\n    throw new Error("Incorrect number of bits written for format " + format);\n\n  return output;\n}\n\nfunction writeBitsForPiece(piece, output, values) {\n  let wrote = false;\n  if (Object(_bitstrings__WEBPACK_IMPORTED_MODULE_4__["isBinaryLiteral"])(piece)) {\n    output |= Object(_bitstrings__WEBPACK_IMPORTED_MODULE_4__["makeBitMaskFromString"])(piece);\n    wrote = true;\n  }\n  else if (values[piece] !== undefined) {\n    let value = values[piece] & Object(_bitstrings__WEBPACK_IMPORTED_MODULE_4__["makeBitMask"])(Object(_opcodes__WEBPACK_IMPORTED_MODULE_0__["getValueBitLength"])(piece));\n    wrote = true;\n    output |= value;\n  }\n\n  return {\n    wrote: wrote,\n    output: output >>> 0,\n  };\n}\n\nfunction determineOpcodeValues(givenOpcode, genericOpcode, allowedFormats, format, values) {\n  const givenPieces = givenOpcode.split(".");\n  const genericPieces = genericOpcode.split(".");\n  if (givenPieces.length !== genericPieces.length)\n    throw new Error(`Given opcode ${givenOpcode} does not have all pieces (${genericOpcode})`);\n\n  for (let i = 0; i < genericPieces.length; i++) {\n    const genericPiece = genericPieces[i];\n\n    if (genericPiece === "fmt" || genericPiece === "ftm3") {\n      if (allowedFormats.indexOf(givenPieces[i].toUpperCase()) === -1)\n        throw new Error(`Format ${givenPieces[i]} is not allowed for ${genericPiece}. Allowed values are ${allowedFormats}`);\n\n      if (genericPiece === "fmt")\n        values["fmt"] = Object(_regs__WEBPACK_IMPORTED_MODULE_2__["getFmtBits"])(givenPieces[i]);\n      else if (genericPiece === "fmt3")\n        values["fmt3"] = Object(_regs__WEBPACK_IMPORTED_MODULE_2__["getFmt3Bits"])(givenPieces[i]);\n    }\n\n    if (genericPiece === "cond")\n      values["cond"] = Object(_regs__WEBPACK_IMPORTED_MODULE_2__["getCondBits"])(givenPieces[i]);\n  }\n}\n\n\n//# sourceURL=webpack://MIPSInst/./src/parse.js?')},"./src/print.js":
/*!**********************!*\
  !*** ./src/print.js ***!
  \**********************/
/*! exports provided: print */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "print", function() { return print; });\n/* harmony import */ var _opcodes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./opcodes */ "./src/opcodes.js");\n/* harmony import */ var _regs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./regs */ "./src/regs.js");\n/* harmony import */ var _immediates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./immediates */ "./src/immediates.js");\n/* harmony import */ var _bitstrings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bitstrings */ "./src/bitstrings.js");\n\n\n\n\n\n/**\n * Prints a string representation of a MIPS instruction.\n *\n * With the `intermediate` option, this can also be used as a convenient base\n * for a disassembler. The object output with `intermediate` can be manipulated\n * prior to calling `print` with it again.\n * @param {Number|Array|ArrayBuffer|DataView|Object} inst MIPS instruction, or intermediate object format.\n * @param {Object} opts Behavior options\n * @param {String} opts.casing "toUpperCase" (default), "toLowerCase"\n * @param {Boolean} opts.commas True to separate values by commas\n * @param {Boolean} opts.include$ True to prefix registers with dollar sign\n * @param {Boolean} opts.intermediate: Output an object intermediate format instead of a string\n * @param {Number} opts.numBase Number format. 16 (hex, default), 10 (decimal)\n * @returns {String|Array|Object} Returns a string representation of the given\n * MIPS instruction code(s).\n * If multiple values are given (array) then multiple values are returned.\n * When the `intermediate` option is passed, the return type is an object.\n */\nfunction print(inst, opts) {\n  opts = _getFinalOpts(opts);\n\n  if (Array.isArray(inst))\n    return inst.map(i => _print(i, opts));\n\n  const isArrayBuffer = inst instanceof ArrayBuffer;\n  if (isArrayBuffer || inst instanceof DataView) {\n    const dataView = isArrayBuffer ? new DataView(inst) : inst;\n    const result = [];\n    for (let i = 0; i < dataView.byteLength; i += 4) {\n      result.push(_print(dataView.getUint32(i), opts));\n    }\n    return result;\n  }\n\n  const inputType = typeof inst;\n  if (inputType === "number" || inputType === "object")\n    return _print(inst, opts);\n\n  throw new Error("Unexpected input to print.");\n}\n\nfunction _getFinalOpts(givenOpts) {\n  return Object.assign({\n    casing: "toUpperCase",\n    commas: false,\n    include$: false,\n    intermediate: false,\n    numBase: 16\n  }, givenOpts);\n}\n\nfunction _print(inst, opts) {\n  let opcodeObj, opName, values;\n  if (typeof inst === "number") {\n    opName = Object(_opcodes__WEBPACK_IMPORTED_MODULE_0__["findMatch"])(inst);\n    if (!opName)\n      throw new Error("Unrecognized instruction");\n\n    opcodeObj = Object(_opcodes__WEBPACK_IMPORTED_MODULE_0__["getOpcodeDetails"])(opName);\n\n    values = _extractValues(inst, opcodeObj.format);\n    values.op = opName;\n  }\n  else if (typeof inst === "object") {\n    if (!inst.op)\n      throw new Error("Instruction object did not contain op");\n\n    opcodeObj = Object(_opcodes__WEBPACK_IMPORTED_MODULE_0__["getOpcodeDetails"])(inst.op);\n\n    values = inst;\n  }\n  else\n    throw new Error(`Unexpected value ${inst}`);\n\n  if (!opcodeObj)\n    throw new Error("Invalid opcode");\n\n  if (opts.intermediate)\n    return values;\n\n  return _printValues(values, opcodeObj, opts);\n}\n\nfunction _printValues(values, opcodeObj, opts) {\n  let result = _formatOpcode(values, opts);\n\n  function _getRegName(displayEntry) {\n    switch (displayEntry) {\n      case "rs":\n      case "rt":\n      case "rd":\n        return Object(_regs__WEBPACK_IMPORTED_MODULE_1__["getRegName"])(values[displayEntry]);\n\n      case "fs":\n      case "ft":\n      case "fd":\n        return Object(_regs__WEBPACK_IMPORTED_MODULE_1__["getFloatRegName"])(values[displayEntry]);\n    }\n  }\n\n  const display = opcodeObj.display;\n  for (let i = 0; i < display.length; i++) {\n    let displayEntry = display[i];\n\n    if (displayEntry.endsWith("?")) {\n      displayEntry = displayEntry.replace("?", "");\n      if (values[displayEntry] === undefined)\n        continue; // Optional value, not set.\n    }\n\n    let value = values[displayEntry];\n    if (value === undefined && displayEntry !== "(" && displayEntry !== ")") {\n      throw new Error(`Expected ${displayEntry} value, got undefined`);\n    }\n\n    let addComma = opts.commas;\n\n    switch (displayEntry) {\n      case "rs":\n      case "rt":\n      case "rd":\n      case "fs":\n      case "ft":\n      case "fd":\n        if (!result.endsWith("("))\n          result += " ";\n        result += _formatReg(_getRegName(displayEntry), opts);\n        break;\n\n      case "(":\n      case ")":\n        addComma = false;\n        if (result.endsWith(","))\n          result = result.slice(0, -1); // Lop off comma, since we are involved in a parenthesis open/close\n\n        result += displayEntry;\n        break;\n    }\n\n    const immDetails = Object(_immediates__WEBPACK_IMPORTED_MODULE_2__["getImmFormatDetails"])(displayEntry);\n    if (immDetails) {\n      if (!result.endsWith("("))\n        result += " ";\n\n      if (immDetails.signed && immDetails.bits === 16) {\n        value = Object(_immediates__WEBPACK_IMPORTED_MODULE_2__["makeInt16"])(value);\n      }\n      if (immDetails.shift) {\n        value = value << immDetails.shift;\n      }\n\n      result += _formatNumber(value, opts);\n    }\n\n    if (addComma && (i !== display.length - 1) && !result.endsWith(",")) {\n      result += ",";\n    }\n  }\n\n  return result.trim();\n}\n\nfunction _extractValues(inst, format) {\n  let values = {};\n  for (let i = format.length - 1; i >= 0; i--) {\n    let value, bitLength;\n    let piece = format[i];\n    if (Array.isArray(piece)) {\n      for (let j = piece.length - 1; j >= 0; j--) {\n        bitLength = Object(_opcodes__WEBPACK_IMPORTED_MODULE_0__["getValueBitLength"])(piece[j]);\n        value = inst & Object(_bitstrings__WEBPACK_IMPORTED_MODULE_3__["makeBitMask"])(bitLength);\n\n        if (Object(_bitstrings__WEBPACK_IMPORTED_MODULE_3__["isBinaryLiteral"])(piece[j])) {\n          if (piece[j] === Object(_bitstrings__WEBPACK_IMPORTED_MODULE_3__["padBitString"])(value.toString(2), bitLength)) {\n            piece = piece[j];\n            break;\n          }\n        }\n        else {\n          piece = piece[j];\n          break;\n        }\n      }\n    }\n    else {\n      bitLength = Object(_opcodes__WEBPACK_IMPORTED_MODULE_0__["getValueBitLength"])(piece);\n      value = inst & Object(_bitstrings__WEBPACK_IMPORTED_MODULE_3__["makeBitMask"])(bitLength);\n    }\n\n    if (Object(_bitstrings__WEBPACK_IMPORTED_MODULE_3__["isBinaryLiteral"])(piece)) {\n      inst >>>= bitLength;\n      continue;\n    }\n\n    values[piece] = value;\n\n    inst >>>= bitLength;\n  }\n\n  return values;\n}\n\nfunction _formatNumber(num, opts) {\n  if (num === 0)\n    return num.toString(opts.numBase);\n\n  let value = "";\n  if (num < 0)\n    value += "-";\n\n  if (opts.numBase === 16)\n    value += "0x";\n  else if (opts.numBase === 8)\n    value += "0o";\n  else if (opts.numBase === 2)\n    value += "0b";\n\n  value += _applyCasing(Math.abs(num).toString(opts.numBase), opts.casing);\n  return value;\n}\n\nfunction _formatReg(regStr, opts) {\n  let value = "";\n  if (opts.include$)\n    value += "$";\n  value += _applyCasing(regStr, opts.casing);\n  return value;\n}\n\nfunction _formatOpcode(values, opts) {\n  const pieces = values.op.split(".");\n  for (let i = 0; i < pieces.length; i++) {\n    if (pieces[i] === "fmt") {\n      if (values.hasOwnProperty("fmt3"))\n        pieces[i] = Object(_regs__WEBPACK_IMPORTED_MODULE_1__["getFmt3Name"])(values["fmt3"]);\n      else if (values.hasOwnProperty("fmt"))\n        pieces[i] = Object(_regs__WEBPACK_IMPORTED_MODULE_1__["getFmtName"])(values["fmt"]);\n      else\n        throw new Error("Format value not available");\n    }\n    else if (pieces[i] === "cond") {\n      if (values.hasOwnProperty("cond"))\n        pieces[i] = Object(_regs__WEBPACK_IMPORTED_MODULE_1__["getCondName"])(values["cond"]);\n      else\n        throw new Error("Condition value not available");\n    }\n  }\n  let opcode = pieces.join(".");\n\n  return _applyCasing(opcode, opts.casing);\n}\n\nfunction _applyCasing(value, casing) {\n  switch (casing) {\n    case "toLowerCase":\n      return value.toLowerCase();\n\n    case "toUpperCase":\n    default:\n      return value.toUpperCase();\n  }\n}\n\n\n//# sourceURL=webpack://MIPSInst/./src/print.js?')},"./src/regex.js":
/*!**********************!*\
  !*** ./src/regex.js ***!
  \**********************/
/*! exports provided: getOpcode, makeRegexForOpcode, isReg, isFloatReg */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOpcode", function() { return getOpcode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeRegexForOpcode", function() { return makeRegexForOpcode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReg", function() { return isReg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFloatReg", function() { return isFloatReg; });\n/* harmony import */ var _regs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regs */ "./src/regs.js");\n/* harmony import */ var _immediates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./immediates */ "./src/immediates.js");\n\n\n\nconst opRegex = "([A-Za-z0-3.]+)";\nconst immRegex = "(-)?0?([xbo]?)([A-Fa-f0-9]+)";\nconst regRegex = "\\\\$?(\\\\w+)";\nconst floatRegRegex = "\\\\$?[Ff]([0-9]+)";\n\nconst opcodeRegex = new RegExp("^\\\\s*" + opRegex);\n\nconst _regexCache = Object.create(null);\n\n// Gets the op string from a given entire instruction.\n// This is a general form (.fmt rather than .S, .D, etc.)\nfunction getOpcode(str) {\n  const match = opcodeRegex.exec(str);\n  if (match) {\n    const pieces = match[1].split("."); // Could be .fmt, .cond.fmt, etc\n    if (pieces.length === 1)\n      return pieces[0].toLowerCase();\n\n    // Loop from the end, as the end has the .fmt for tricky things like .D.W\n    let result = "";\n    let foundFmt = false;\n    let foundCond = false;\n    for (let i = pieces.length - 1; i > 0; i--) {\n      let piece = pieces[i];\n      if (!foundFmt) {\n        if (piece === "fmt" || Object(_regs__WEBPACK_IMPORTED_MODULE_0__["isFmtString"])(piece)) {\n          foundFmt = true;\n          piece = "fmt";\n        }\n      }\n\n      if (!foundCond) {\n        if (Object(_regs__WEBPACK_IMPORTED_MODULE_0__["isCondString"])(piece)) {\n          foundCond = true;\n          piece = "cond";\n        }\n      }\n\n      result = "." + piece + result;\n    }\n\n    return (pieces[0] + result).toLowerCase();\n  }\n  return null;\n}\n\nfunction makeRegexForOpcode(opcode, opcodeObj) {\n  if (_regexCache[opcode]) {\n    return _regexCache[opcode];\n  }\n\n  const parts = [opRegex];\n  const display = opcodeObj.display;\n  for (let i = 0; i < display.length; i++) {\n    const part = display[i];\n    const optional = part.endsWith("?");\n\n    let regexPart = "";\n    if (optional)\n      regexPart += "(?:[,\\\\s]+";\n\n    if (display[i + 1] === "(") {\n      if (optional)\n        throw new Error("Not prepared to generate optional regex with parenthesis");\n\n      if (display[i + 3] !== ")")\n        throw new Error("Not prepared to generate regex for multiple values in parenthesis"); // Or no closing paren\n\n      regexPart += makeParenthesisRegex(getRegexForPart(part), getRegexForPart(display[i + 2]));\n      i = i + 3;\n    }\n    else {\n      regexPart += getRegexForPart(part);\n    }\n\n    if (optional)\n      regexPart += ")?";\n\n    parts.push(regexPart);\n  }\n\n  let regexStr =\n    "^\\\\s*" +\n    parts.reduce((str, next, index) => {\n      if (index === 0 || partIsOptional(next))\n        return str + next;\n\n      return str + "[,\\\\s]+" + next;\n    }, "") +\n    "\\\\s*$";\n\n  const regex = new RegExp(regexStr);\n  _regexCache[opcode] = regex;\n  return regex;\n}\n\nfunction getRegexForPart(part) {\n  if (isReg(part))\n    return regRegex;\n  if (isFloatReg(part))\n    return floatRegRegex;\n\n  if (Object(_immediates__WEBPACK_IMPORTED_MODULE_1__["getImmFormatDetails"])(part))\n    return immRegex;\n\n  throw new Error(`Unrecognized display entry ${part}`);\n}\n\nfunction makeParenthesisRegex(regex1, regex2) {\n  return regex1 + "\\\\s*" + "\\\\(?" + regex2 + "\\\\)?";\n}\n\nfunction partIsOptional(partStr) {\n  return partStr.startsWith("(?:");\n}\n\nfunction isReg(entry) {\n  if (!entry)\n    return false;\n\n  switch (entry.substr(0, 2)) {\n    case "rs":\n    case "rt":\n    case "rd":\n      return true;\n  }\n  return false;\n}\n\nfunction isFloatReg(entry) {\n  if (!entry)\n    return false;\n\n  switch (entry.substr(0, 2)) {\n    case "fs":\n    case "ft":\n    case "fd":\n      return true;\n  }\n  return false;\n}\n\n\n//# sourceURL=webpack://MIPSInst/./src/regex.js?')},"./src/regs.js":
/*!*********************!*\
  !*** ./src/regs.js ***!
  \*********************/
/*! exports provided: getRegBits, getRegName, getFloatRegName, getFmtBits, getFmtName, getFmt3Bits, getFmt3Name, isFmtString, getCondBits, getCondName, isCondString */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRegBits", function() { return getRegBits; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRegName", function() { return getRegName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFloatRegName", function() { return getFloatRegName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFmtBits", function() { return getFmtBits; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFmtName", function() { return getFmtName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFmt3Bits", function() { return getFmt3Bits; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFmt3Name", function() { return getFmt3Name; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFmtString", function() { return isFmtString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCondBits", function() { return getCondBits; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCondName", function() { return getCondName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCondString", function() { return isCondString; });\nconst regs = {\n  r0: 0,\n  zero: 0,\n  at: 1,\n  v0: 2,\n  v1: 3,\n  a0: 4,\n  a1: 5,\n  a2: 6,\n  a3: 7,\n  t0: 8,\n  t1: 9,\n  t2: 10,\n  t3: 11,\n  t4: 12,\n  t5: 13,\n  t6: 14,\n  t7: 15,\n  s0: 16,\n  s1: 17,\n  s2: 18,\n  s3: 19,\n  s4: 20,\n  s5: 21,\n  s6: 22,\n  s7: 23,\n  t8: 24,\n  t9: 25,\n  k0: 26,\n  k1: 27,\n  gp: 28,\n  sp: 29,\n  fp: 30,\n  ra: 31\n};\n\nfunction getRegBits(reg) {\n  if (!reg)\n    return undefined;\n  return regs[reg.toLowerCase()];\n}\n\nfunction getRegName(bits) {\n  for (let name in regs) {\n    if (regs[name] === bits)\n      return name;\n  }\n  return "";\n}\n\nfunction getFloatRegName(bits) {\n  if (typeof bits !== "number")\n    throw new Error("getFloatRegName encountered non-number");\n\n  return "F" + bits;\n}\n\nconst fmts = {\n  S: 16,\n  D: 17,\n  W: 20,\n  L: 21,\n};\n\nfunction getFmtBits(fmtStr) {\n  return fmts[fmtStr.toUpperCase()];\n}\n\nfunction getFmtName(bits) {\n  for (let name in fmts) {\n    if (fmts[name] === bits)\n      return name;\n  }\n  return "";\n}\n\nconst fmt3s = {\n  S: 0,\n  D: 1,\n  W: 4,\n  L: 5,\n};\n\nfunction getFmt3Bits(fmtStr) {\n  return fmt3s[fmtStr.toUpperCase()];\n}\n\nfunction getFmt3Name(bits) {\n  for (let name in fmt3s) {\n    if (fmt3s[name] === bits)\n      return name;\n  }\n  return "";\n}\n\nfunction isFmtString(fmtStr) {\n  return fmts.hasOwnProperty(fmtStr.toUpperCase()) || fmt3s.hasOwnProperty(fmtStr.toUpperCase());\n}\n\nconst conds = {\n  F: 0,\n  UN: 1,\n  EQ: 2,\n  UEQ: 3,\n  OLT: 4,\n  ULT: 5,\n  OLE: 6,\n  ULE: 7,\n  SF: 8,\n  NGLE: 9,\n  SEQ: 10,\n  NGL: 11,\n  LT: 12,\n  NGE: 13,\n  LE: 14,\n  NGT: 15,\n};\n\nfunction getCondBits(condStr) {\n  return conds[condStr.toUpperCase()];\n}\n\nfunction getCondName(bits) {\n  for (let name in conds) {\n    if (conds[name] === bits)\n      return name;\n  }\n  return "";\n}\n\nfunction isCondString(condStr) {\n  return conds.hasOwnProperty(condStr.toUpperCase());\n}\n\n\n//# sourceURL=webpack://MIPSInst/./src/regs.js?')}})},module.exports=factory()},function(n,e,t){"use strict";t.r(e);var r,s=t(0);!function(n){n[n.firstPass=0]="firstPass",n[n.secondPass=1]="secondPass"}(r||(r={}));var i=new RegExp("^(@?@?[\\w\\?\\!]+)\\:");function a(n){var e=n.line.match(i);if(null===e)return!1;var t=e[1];return o(t)||f(t)||(n.currentLabel=t),l(n,t,function(n){return n.memPos+n.outIndex>>>0}(n)),t}function o(n){return 0===n.indexOf("@@")}function f(n){return 0===n.indexOf("@")&&"@"!==n[1]}function l(n,e,t){if(o(e)){if(!n.currentLabel)throw new Error("Local label "+e+" (starts with @@) cannot be used before a global label");!function(n,e,t){var r=n.localSymbols[n.currentLabel];r||(r=n.localSymbols[n.currentLabel]=Object.create(null));r[e]=t}(n,e,t)}else f(e)?function(n,e,t){n.staticSymbols[n.staticSymbols.length-1][e]=t}(n,e,t):function(n,e,t){n.symbols[e]=t,n.symbolsByValue[t]=e,n.symbolOutputMap&&(n.symbolOutputMap[e]=n.outIndex)}(n,e,t)}function c(n,e){if(o(e)){if(!n.currentLabel)throw new Error("Local label "+e+" cannot be referenced in the current scope");var t=n.localSymbols[n.currentLabel];return t&&Object.prototype.hasOwnProperty.call(t,e)?t[e]:null}if(f(e)){var s=function(n){return n.currentPass===r.firstPass?n.staticSymbols[n.staticSymbolIndices[n.staticSymbolIndices.length-1]]:n.staticSymbols[n.staticSymbolIndices[0]]}(n);return Object.prototype.hasOwnProperty.call(s,e)?s[e]:null}return Object.prototype.hasOwnProperty.call(n.symbols,e)?n.symbols[e]:null}function u(n,e){throw new Error(n+"\nLine: "+e.line)}function p(n,e){return function n(e,t){var r=d.exec(e);if(null===r){var s=c(t,e);if(null!==s)return s;var i=function(n){if("string"!=typeof n)return null;var e,t="-"===n[0];return t&&(n=n.substr(1)),e="b"===n[0]||"0"===n[0]&&"b"===n[1]?parseInt(n.substr(2),2):"o"===n[0]||"0"===n[0]&&"o"===n[1]?parseInt(n.substr(2),8):"x"===n[0]||"0"===n[0]&&"x"===n[1]?parseInt(n.substr(2),16):parseInt(n,10),isNaN(e)?null:(t&&(e=-e),e)}(e);if(null!==i)return i;var a=function(n){if(n.length<2)return null;var e=n[0];if(n[n.length-1]!==e)return null;if('"'!==e&&"'"!==e)return null;for(var t="",r=1;r<n.length-1;r++){var s=n[r];if("\\"===s){var i=n[r+1];switch(i){case"\\":case'"':case"'":t+=i,r++;continue}}t+=s}return t}(e);return"string"==typeof a?a:null}var o=r[1];if(!_[o]){var s=c(t,o);return null!==s?s:null}var f="",l=0,p=void 0;for(p=o.length+1;p<e.length-1;p++){var m=e[p];if("("===m)l++;else if(")"===m&&--l<0){p++;break}f+=m}var b="";p<e.length-1&&(b=e.substring(p,e.length));var g=0;if(f&&(g=n(f,t)),null===g)return u("Could not evaluate "+f,t),null;var y=_[o](t,g);return b&&(y+=b),y}(n,e)}var d=new RegExp("^([-\\w]+)\\(([\\(\\),-\\w\\?\\!\\@]*)\\)$","i");var _=Object.create(null);function m(n){2!==n.lineExpressions.length&&u(".definelabel must have two arguments, a label name and value",n);var e=n.lineExpressions[0],t=p(n.lineExpressions[1],n);return"number"!=typeof t?(u("The value in .definelabel must evaluate to a numeric value",n),!1):(l(n,e,t),!0)}_.abs=function(n,e){if("string"==typeof e)throw new Error('Assembler function abs cannot be called with string "'+e+'", value must be a number.');return Math.abs(e)},_.hi=function(n,e){if("string"==typeof e)throw new Error('Assembler function hi cannot be called with string "'+e+'", value must be a number.');var t=e>>>16;return 32768&e&&(t+=1),t},_.lo=function(n,e){if("string"==typeof e)throw new Error('Assembler function lo cannot be called with string "'+e+'", value must be a number.');return 65535&e},_.org=function(n,e){return n.memPos+n.outIndex};var b=new RegExp("^\\.definelabel\\s+(@?@?[\\w\\?\\!]+)[\\s,]+([-\\w\\?\\!\\@]+)$","i");m.matches=function(n){return null!==n.line.match(b)};function g(n){var e=n.line,t=E(e," ","\t");if(-1!==t){var r=h(e.substr(t+1));n.lineExpressions=r}else n.lineExpressions=[]}function y(n){var e=n.line,t=E(e," ","\t");if(-1===t)return e;var r,s,i=e.substring(0,t),a=h(e.substr(t+1));if(n.lineExpressions=a,a.length>0){var o=a.map(function(e,t){var r=p(e,n);return"number"==typeof r&&t===a.length-1&&(r=function(n,e,t){if(function(n){if("b"!==(n=n.toLowerCase())[0])return!1;switch(n){case"bc1f":case"bc1fl":case"bc1t":case"bc1tl":case"beq":case"beql":case"bgez":case"bgezal":case"bgezall":case"bgezl":case"bgtz":case"bgtzl":case"blez":case"blezl":case"bltz":case"bltzal":case"bltzall":case"bltzl":case"bne":case"bnel":return!0}return!1}(n)){var r=t.memPos+t.outIndex,s=e-r;s%4!=0&&u("Misaligned branch instruction detected",t);var i=s/4-1;return i}return e}(i,r,n)),r});n.evaluatedLineExpressions=o,e=i+" "+(r=o,s=a,r.map(function(n,e){return"number"==typeof n?function(n){var e=0===n,t=n<0,r=n.toString(16).toUpperCase();return t&&(r=r.substr(1)),(t?"-":"")+(e?"":"0x")+r}(n):null===n?s[e]:n})).join(" ")}return e}function h(n){var e=[],t="",r="",s=0,i=!1,a="";function o(n){t+=n}function f(){for(;v(t[t.length-1]);)t=t.slice(0,-1);(t=t.trim())&&(e.push(t),t="")}for(var l=0;l<n.length;l++){var c=n[l];switch(r||s||v(a)&&f(),c){case"\\":i||(i=!0);break;case"(":i||r||s++;break;case")":if(!i&&!r){if(s<=0)throw new Error("Imbalanced parenthesis in expression: "+n);s--}break;case'"':case"'":i||(r?r===c&&(r=""):r=c)}o(c),"\\"!==c&&(i=!1),a=c}if(s>0)throw new Error("Imbalanced parenthesis in expression: "+n);if(r)throw new Error("Unterminated string: "+t);return f(),e}function v(n){return","===n||function(n){return" "===n||"\t"===n}(n)}function E(n){for(var e=[],t=1;t<arguments.length;t++)e[t-1]=arguments[t];for(var r=[],s=0,i=e;s<i.length;s++){var a=i[s],o=n.indexOf(a);o>=0&&r.push(o)}return 0===r.length?-1:Math.min.apply(Math,r)}function w(n,e){var t=function(n,e){return new RegExp("^\\."+n+(e?"":"\\s+"),"i")}(n,e);return function(n){return!!n.line.match(t)}}function x(n){1!==n.lineExpressions.length&&u(".org directive requires one numeric argument",n);var e=p(n.lineExpressions[0],n);return"number"!=typeof e?(u("Could not parse .org immediate "+e,n),!1):(e<0&&u(".org directive cannot be negative",n),n.memPos=e>>>0,!0)}function O(n){1!==n.lineExpressions.length&&u(".orga directive requires one numeric argument",n);var e=p(n.lineExpressions[0],n);return"number"!=typeof e?(u("Could not parse .orga immediate "+e,n),!1):(e<0&&u(".orga directive cannot be negative.",n),n.outIndex=e>>>0,!0)}function k(n){1!==n.lineExpressions.length&&u(".align requires one power of two number argument",n);var e=p(n.lineExpressions[0],n);if(null===e&&u("Could not parse .align immediate "+n.lineExpressions,n),"number"!=typeof e)return u(".align requires one power of two number argument",n),!1;for(e%2&&u(".align directive requires a power of two.",n),e<0&&u(".align directive cannot align by a negative value.",n);n.outIndex%e;)n.currentPass===r.secondPass&&n.dataView.setUint8(n.outIndex,0),n.outIndex++;return!0}function P(n){1!==n.lineExpressions.length&&u(".skip directive requires one numeric argument",n);var e=p(n.lineExpressions[0],n);return"number"!=typeof e?(u("Could not parse .skip immediate "+e,n),!1):(e<0&&u(".skip directive cannot skip a negative length.",n),n.outIndex+=e,!0)}function I(n){if(!n.lineExpressions.length||n.lineExpressions.length>2)throw new Error(".fill directive takes a length and optional value");var e,t;if("number"!=typeof(e=p(n.lineExpressions[0],n)))return u("Could not parse .fill length "+n.lineExpressions[0],n),!1;if(e<0&&u(".fill length must be positive.",n),n.lineExpressions.length>1){if("number"!=typeof(t=p(n.lineExpressions[1],n)))return u("Could not parse .fill value "+n.lineExpressions[1],n),!1}else t=0;if(n.currentPass===r.secondPass)for(var s=0;s<e;s++)n.dataView.setInt8(n.outIndex+s,t);return n.outIndex+=e,!0}function D(n){return M(n,!0)}function M(n,e){var t=[];if(n.lineExpressions.forEach(function(e){var r=p(e,n);if(null===r&&u("Could not parse .ascii value "+e,n),"number"==typeof r)t.push(r);else if("string"==typeof r)for(var s=0;s<r.length;s++)t.push(r.charCodeAt(s))}),e&&t.push(0),n.currentPass===r.secondPass)for(var s=0;s<t.length;s++)t[s]<0?n.dataView.setInt8(n.outIndex+s,t[s]):n.dataView.setUint8(n.outIndex+s,t[s]);return n.outIndex+=t.length,!0}function B(n){if(n.currentPass===r.secondPass){n.evaluatedLineExpressions.length||u(".byte directive requires arguments",n),n.evaluatedLineExpressions.some(function(n){return"number"!=typeof n})&&u(".byte directive requires numeric arguments",n);for(var e=n.evaluatedLineExpressions,t=0;t<e.length;t++)e[t]<0?n.dataView.setInt8(n.outIndex+t,e[t]):n.dataView.setUint8(n.outIndex+t,e[t])}return n.outIndex+=n.lineExpressions.length,!0}x.matches=w("org"),O.matches=w("orga"),k.matches=w("align"),P.matches=w("skip"),I.matches=w("fill"),D.matches=w("asciiz"),M.matches=w("ascii");var S=w("byte"),j=w("db");function L(n){if(n.currentPass===r.secondPass){n.evaluatedLineExpressions.length||u(".halfword directive requires arguments",n),n.evaluatedLineExpressions.some(function(n){return"number"!=typeof n})&&u(".halfword directive requires numeric arguments",n);for(var e=n.evaluatedLineExpressions,t=0;t<e.length;t++)e[t]<0?n.dataView.setInt16(n.outIndex+2*t,e[t]):n.dataView.setUint16(n.outIndex+2*t,e[t])}return n.outIndex+=2*n.lineExpressions.length,!0}B.matches=function(n){return S(n)||j(n)};var R=w("halfword"),C=w("dh");function A(n){if(n.currentPass===r.secondPass){n.evaluatedLineExpressions.length||u(".word directive requires arguments",n),n.evaluatedLineExpressions.some(function(n){return"number"!=typeof n})&&u(".word directive requires numeric arguments",n);for(var e=n.evaluatedLineExpressions,t=0;t<e.length;t++)e[t]<0?n.dataView.setInt32(n.outIndex+4*t,e[t]):n.dataView.setUint32(n.outIndex+4*t,e[t])}return n.outIndex+=4*n.lineExpressions.length,!0}L.matches=function(n){return R(n)||C(n)};var U,T=w("word"),q=w("dw");function W(n){if(n.currentPass===r.secondPass){n.evaluatedLineExpressions.length||u(".float directive requires arguments",n),n.evaluatedLineExpressions.some(function(n){return"number"!=typeof n})&&u(".float directive requires numeric arguments",n);for(var e=n.evaluatedLineExpressions,t=0;t<e.length;t++)n.dataView.setFloat32(n.outIndex+4*t,e[t])}return n.outIndex+=4*n.lineExpressions.length,!0}A.matches=function(n){return T(n)||q(n)},W.matches=w("float"),function(n){n[n.None=0]="None",n[n.AcceptingBlock=1]="AcceptingBlock",n[n.ExecutingBlock=2]="ExecutingBlock",n[n.NoLongerAcceptingBlock=4]="NoLongerAcceptingBlock",n[n.SawElse=8]="SawElse"}(U||(U={}));var F=U.AcceptingBlock|U.ExecutingBlock|U.NoLongerAcceptingBlock;function N(n,e){n.ifElseStack[n.ifElseStack.length-1]&=~F,n.ifElseStack[n.ifElseStack.length-1]|=e}function K(n){n.lineExpressions.length||u("A condition must be passed to an if directive",n),n.lineExpressions.length>1&&u("Only a single condition can be passed to an if directive",n);var e=p(n.lineExpressions[0],n);return null===e&&u("Could not parse .if condition",n),"number"!=typeof e&&u("Condition of if directive must evaluate to a numeric value, saw: "+e,n),e?n.ifElseStack.push(U.ExecutingBlock):n.ifElseStack.push(U.AcceptingBlock),!0}function V(n){n.lineExpressions.length&&u("The else directive cannot take a condition or parameters",n),n.ifElseStack.length||u("An else directive was reached, but there was no previous if directive",n);var e=n.ifElseStack[n.ifElseStack.length-1];switch(e&U.SawElse&&u("Encountered another else directive, but an else directive was already passed",n),e&F){case U.AcceptingBlock:N(n,U.ExecutingBlock);break;case U.ExecutingBlock:N(n,U.NoLongerAcceptingBlock);break;case U.NoLongerAcceptingBlock:break;default:u("Unexpected conditional block state: "+e.toString(16),n)}return n.ifElseStack[n.ifElseStack.length-1]|=U.SawElse,!0}function z(n){n.lineExpressions.length||u("A condition must be passed to an elseif directive",n),n.lineExpressions.length>1&&u("Only a single condition can be passed to an elseif directive",n),n.ifElseStack.length||u("An elseif directive was reached, but there was no previous if directive",n);var e=n.ifElseStack[n.ifElseStack.length-1];e&U.SawElse&&u("Encountered an elseif after seeing an else directive",n);var t=p(n.lineExpressions[0],n);switch(null===t&&u("Could not parse .elseif condition",n),"number"!=typeof t&&u("Condition of elseif directive must evaluate to a numeric value, saw: "+t,n),e&F){case U.AcceptingBlock:t&&N(n,U.ExecutingBlock);break;case U.ExecutingBlock:N(n,U.NoLongerAcceptingBlock);break;case U.NoLongerAcceptingBlock:break;default:u("Unexpected conditional block state: "+e.toString(16),n)}return!0}function $(n){return n.lineExpressions.length&&u("The endif directive cannot take a condition or parameters",n),n.ifElseStack.length||u("An endif directive was reached, but there was no previous if directive",n),n.ifElseStack.pop(),!0}function G(n){n.lineExpressions.length||u("A file name must be passed to an include directive",n),n.lineExpressions.length>1&&u("Only a single file name can be passed to an include directive",n);var e=p(n.lineExpressions[0],n);if(null===e&&u("Could not parse .include file name",n),"string"==typeof e){var t=n.files[e];"string"!=typeof t&&u("The "+e+" file was not a string",n),n.currentPass===r.firstPass?(n.linesToInsert=".beginfile\n"+t+"\n.endfile",n.line=""):u("The `include` directive shouldn't be present after the first assembly phase",n)}else u("File name of include directive must evaluate to a string, saw: "+e,n)}function Q(n){return n.lineExpressions.length&&u("The beginfile directive takes no arguments",n),function(n){if(n.currentPass===r.firstPass){n.staticSymbols.push(Object.create(null));var e=n.staticSymbolIndices[n.staticSymbolIndices.length-1],t=n.staticSymbols.length-1;n.staticSymbolIndices.before[t]=e,n.staticSymbolIndices.push(t)}else n.staticSymbolIndices.shift()}(n),!0}function Z(n){return n.lineExpressions.length&&u("The endfile directive takes no arguments",n),function(n){if(n.currentPass===r.firstPass){var e=n.staticSymbolIndices;e.push(e.before[e[e.length-1]])}else n.staticSymbolIndices.shift()}(n),!0}function H(n){var e=function(n){return new RegExp("^"+n+"\\s+","i")}(n);return function(n){return!!n.line.match(e)}}function J(n){n.currentPass===r.firstPass?(2!==n.lineExpressions.length&&u("The `beqz` macro must take a register and label",n),n.line="",n.linesToInsert="BEQ "+n.lineExpressions[0]+" R0 "+n.lineExpressions[1]):u("The `beqz` macro shouldn't be present after the first assembly phase",n)}function X(n){n.currentPass===r.firstPass?(2!==n.lineExpressions.length&&u("The `bnez` macro must take a register and label",n),n.line="",n.linesToInsert="BNE "+n.lineExpressions[0]+" R0 "+n.lineExpressions[1]):u("The `bnez` macro shouldn't be present after the first assembly phase",n)}function Y(n){n.currentPass===r.firstPass?(2!==n.lineExpressions.length&&u("The `bnezl` macro must take a register and label",n),n.line="",n.linesToInsert="BNEL "+n.lineExpressions[0]+" R0 "+n.lineExpressions[1]):u("The `bnezl` macro shouldn't be present after the first assembly phase",n)}function nn(n){if(n.currentPass===r.firstPass){n.lineExpressions.length<=1&&u("The `li` macro must take a register and immediate",n);var e=n.lineExpressions[0],t=p(n.lineExpressions[1],n);if(null===t&&u("Could not parse `li` immediate value",n),"number"==typeof t)if(n.line="",t>=-32768&&t<=32767)n.linesToInsert="ADDIU "+e+", R0, "+t;else if(t>0&&t<=65535)n.linesToInsert="ORI "+e+", R0, "+t;else if(0==(65535&t))n.linesToInsert="LUI "+e+", "+(t>>16);else if(t>=-4294967295&&t<=4294901759){var s=0!=(32768&t);n.linesToInsert="LUI "+e+", "+((t>>>16)+(s?1:0))+"\nADDIU "+e+", "+e+", "+(65535&t)}else u("li immediate value "+t+" seems out of range",n);else u("Immediate value of `li` macro must evaluate to a number, saw: "+t,n)}else u("The `li` macro shouldn't be present after the first assembly phase",n)}function en(n){n.currentPass===r.firstPass?(2!==n.lineExpressions.length&&u("The `move` macro must take two registers",n),n.line="",n.linesToInsert="ADDU "+n.lineExpressions[0]+" "+n.lineExpressions[1]+" R0"):u("The `move` macro shouldn't be present after the first assembly phase",n)}K.matches=w("if"),V.matches=w("else",!0),z.matches=w("elseif"),$.matches=w("endif",!0),G.matches=w("include"),Q.matches=w("beginfile",!0),Z.matches=w("endfile",!0),J.matches=H("beqz"),X.matches=H("bnez"),Y.matches=H("bnezl"),nn.matches=H("li"),en.matches=H("move");var tn=[m,x,O,k,P,I,M,D,B,L,A,W,K,z,V,$,G,Q,Z],rn=[J,X,Y,nn,en];function sn(n){for(var e=0,t=tn;e<t.length;e++){var r=t[e];if(r.matches(n))return r}for(var s=0,i=rn;s<i.length;s++){var a=i[s];if(a.matches(n))return a}return null}function an(n,e){e(n)}function on(n,e){return n.substr(0,e.length)===e}function fn(n,e){e=e||{};for(var t=un(n),i=function(n){var e=[0];return e.before=Object.create(null),{buffer:null,dataView:null,line:"",memPos:0,outIndex:0,symbols:Object.create(null),symbolsByValue:Object.create(null),symbolOutputMap:n.symbolOutputMap,currentLabel:null,localSymbols:Object.create(null),staticSymbols:[Object.create(null)],staticSymbolIndices:e,currentPass:r.firstPass,lineExpressions:[],evaluatedLineExpressions:null,ifElseStack:[],files:n.files||Object.create(null),linesToInsert:null}}(e),a=[],o=[],f=0;f<t.length;f++){var l=t[f];if(i.line=l,ln(i))l&&o.push(l);else{l=cn(i);var c=sn(i);if(c?(g(i),an(i,c),l=i.line):l&&(i.outIndex+=4),l&&o.push(l),"linesToInsert"in i&&i.linesToInsert){var p=un(i.linesToInsert);t.splice.apply(t,[f+1,0].concat(p)),i.linesToInsert=null}}}return t=o,i.buffer=e.buffer||new ArrayBuffer(i.outIndex),i.dataView=new DataView(i.buffer),i.memPos=0,i.outIndex=0,i.currentPass=r.secondPass,t.forEach(function(n){if(i.line=n,i.lineExpressions=[],i.evaluatedLineExpressions=[],ln(i))return n;var t=sn(i);if(t)return y(i),void an(i,t);var r,o=function(n,e){return n.symbolsByValue[e]||null}(i,i.memPos+i.outIndex);null!==o&&(i.currentLabel=o),n=i.line=y(i),e.text&&a.push(n);try{r=Object(s.parse)(n)}catch(n){return void u(n,i)}i.dataView.setUint32(i.outIndex,r),i.outIndex+=4}),i.ifElseStack.length&&u("An if directive was used without an endif directive",i),0!==i.staticSymbolIndices[0]&&u("A beginfile directive was used without an endfile directive",i),e.text?a:i.buffer}function ln(n){var e,t;return!!n.ifElseStack.length&&!(n.ifElseStack[n.ifElseStack.length-1]&U.ExecutingBlock||(e=n.line,t=e.toLowerCase(),on(t,".if")||on(t,".else")||on(t,".endif")))}function cn(n){for(var e;e=a(n);)n.line=n.line.substr(e.length+1).trim();return n.line}function un(n){var e=function(n){if("string"==typeof n)return n.split(/\r?\n/);if(!Array.isArray(n))throw new Error("Input must be a string or array of strings");return n}(n);return e=(e=(e=function(n){var e=!1,t=n.map(function(n){if(e){var t=n.indexOf("*/");t>=0&&(n=n.substr(t+2),e=!1)}if(e)return"";for(var r=n.indexOf("/*");r>=0;){if(pn(n,r))r++;else{var t=n.indexOf("*/",r+2);if(!(t>=0)){n=n.substr(0,r),e=!0;break}n=n.substr(0,r)+n.substr(t+2)}r=n.indexOf("/*",r)}for(var s=n.indexOf(";");s>=0;){if(!pn(n,s)){n=n.substr(0,s),e=!1;break}s=n.indexOf(";",s+1)}for(var i=n.indexOf("//");i>=0;){if(!pn(n,i)){n=n.substr(0,i),e=!1;break}i=n.indexOf("//",i+2)}return n});if(e)throw new Error("Unclosed block comment detected.");return t}(e=e.filter(function(n){return"string"==typeof n}))).map(function(n){return n.trim()})).filter(Boolean)}function pn(n,e){return dn(n,e,'"')||dn(n,e,"'")}function dn(n,e,t){var r=n.indexOf(t);return-1!==r&&(!(r>e)&&-1!==n.indexOf(t,e))}t.d(e,"assemble",function(){return fn})}])});